# Vue markup document

[English](./README.md) | Русский

Vue labeling image - это компонент для vue.js, позволяющий маркировать данные на картинках. Проще говоря, это UI для нейронок. Примером для создания данного компонента послужил данный [проект](https://github.com/HumanSignal/labelImg "LabelImg"), сейчас он уже не актуален. Eсли вам интересна данная тема, я рекомендую вам обратить внимание вот на этот [репозиторий](https://github.com/HumanSignal/label-studio "label-studio"). По большей части я разрабатывал компоненты для маркирования текста, поэтому основное предназначение моего компонента это OCR, но он подойдет и для других похожих задач. Как пример, я могу указать на yandex и google картинки. Там можно загрузить свою картирку, а после выделить какую-то определенную её область, мой компонент вполне с этой задачей справится.

Для корректной работы данного компонента нужен vue.js версии 3.5 и выше (я использую useTemplateRef и defineModel). При разработке данного компонента я использовал vue.js версии 3.5.17.

Чтобы не переписывать код в пустую, я бы вам посоветовал открыть [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры") и самим посмотреть, что может мой компонент. Я укажу ссылки на примеры с кодом, так наверное будет проще.

И так, откройте [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры"), выберите какую-нибудь картинку, и разметьте произвольные области (нажмите левую кнопку мыши, и не отпуская её выделите произвольную область. Если вы смотрите страницу примеров с мобильного телефона, то проведите пальцем по картинке). Маркированные области можно переносить по картинке и менять их размеры, для этого потяните их за края.

## Установка, минимальная настройка

Как и положено, наверное стоит сказать, что для установки данного компонента нужен Node.js и NPM, но вы наверное и сами это знаете. Установить данный компонент можно следующим способом:

```shell
npm install vue-labeling-image;
```

Если у вас нет проблем с интернетом, то компонент вы установите. Дальше нужно будет его подключить, это можно будет сделать следующим способом:

```vue
<template>
  <labeling-image
    :image-src="file"
    v-model="areas"
  />
</template>

<script setup>
  import LabelingImage from 'vue-labeling-image';
  import 'vue-labeling-image/styles.css';

  const file = ref(null);
  const areas = ref([]);
</script>
```

Если вы планируете использовать мой компонент более чем на одной странице, то имеет смысл подключить CSS глобально, в main.js, или App.vue, тут выбирайте как вам будет удобнее.

Как можно заметить, важными являются 2 строчки, **image-src="file"** и **v-model="areas"**.

**Image-src** - входной параметр, в который нужно передать картинку которую нужно маркировать. В подавляющем большинстве случаев, это будет двоичный файл, но возможно передать и путь к картинке, и саму картинку в формате base64. Вполне естественно, что без этого параметра ничего маркировать не получится. Саму картинку вы скорее всего отправите на сервер через **FormData**. Я бы порекомендовал вам посмотреть [код примера](https://github.com/neuro-tools-25/vue-labeling-image/blob/main/src/components/examples/MainExample.vue "Пример"). Если вы начинающий frontend-разработчик, то я рекомендую вам посмотреть код того, как работает [стилизованный input выбора файла](https://github.com/neuro-tools-25/vue-labeling-image/blob/main/src/UI/UIFile.vue "Пример").

**Areas** - это массив объектов. Он содержит параметры маркированных областей и обязательно должен содержать следующие поля:

```javascript
const areas = [
  {
    id: 1759337013345,
    x: 15,
    y: 15,
    width: 30,
    height: 30,
  }
];
```

Тут нужно оговориться, что единого API для нейронок не существует. Когда я первый раз писал UI для нейронки, мне нужно было указать координаты начальной и конечной точки (**X1, Y1, X2, Y2**). После, для одного НИИ нужно было создать UI, который бы принимал и отдавал начальую и конечную точку в следующем виде: **\[\[X1, Y1\], \[X2, Y2\]\]**. Это массив, в котором находятся координаты начальной и конечной точки, первый массив это начальная точка, второй массив это конечная точка. На аутсорсе я писал UI которое бы принимало и отдавало координаты в следующем виде:

```javascript
{
  name_area: [
    {
      x: "10",
      y: "10"
    },
    {
      x: "10",
      y: "40"
    },
    {
      x: "40",
      y: "40"
    },
    {
      x: "40",
      y: "10"
    }
  ]
}
```

Чтобы вы не ломали голову, это массив, в котором 4 объекта, это точки. Они идут от верхней левой, к нижней левой точке, затем к правой нижней точке, и последняя точка - правая верхняя. Как не трудно догадаться, получается прямоугольник, мне нужно было его построить. Возвращать маркированные области мне нужно было в этих форматах, в зависимости от API. Последнее из того, что я делал, нейронке была нужна начальная точка (координаты X, Y) и ширина с высотой маркированной области.

Если подводить не большой итог, можно выделить, что для всех нейронок, координаты точек должны быть представлены в относительных величинах (процентах). Смотрите, картинки могут быть разными, возможно загрузить картинку в 2000px и в 300px. Если область в которую нужно вставить картинку 600px, то на картинке в 2000px при точных величинах (px), нейронка не сможет понять, где искать текст, она же сожмется до 600px. Нужно будет ещё отправить размеры области в которую картинка вставляется. Это лишние расчеты. Гораздо проще отправить данные в относительных величинах, а нейронка эти данные разметит как нужно.

В моём случае **id** - это id маркированной области, по умолчанию, во время маркирования, это текущая дата в милисекундах, но если back вернет что-то другое, то ничего страшного. Главное, чтобы id-ки у маркированных областей были уникальными. **X** и **y** - это координаты начальной точки, **width** и **height** это ширина и высота маркированной области.

Как можно догадаться, за основу я взял последнее из того, что я делал. На мой взгляд такое API более понятно человеку. В будующем я планирую сделать так, чтобы мой компонент подстраивался под любое API, но пока что, мой компонент будет строить маркированные области так.

## Рекомендации по использованию

Eсли вы планируете использовать мой компонент на мобильном устройстве или планшете, то имейте в виду следующее. Когда картинка не выбрана, вы можете прокручивать вниз когда касаетесь моего компонента. Когда же картинка выбрана, то вниз прокрутить вы уже не сможете, скорее всего при касании моего компонента у вас будут появляться маркированные области. Для того, чтобы картинку можно было маркировать, мне приходится отключать обычное поведение для **touch**, иначе маркировать ничего не получится, при маркировании будет происходить прокрутка вниз/вверх. Самый простой вариант, это оставить по краям не большое расстояние, оно нужно для того, чтобы касаясь его можно было прокручивать вниз/вверх. Как вариант, можно добавить кнопку, которая бы включала/отключала возможность редактирования компонента. Для этого просто добавьте к моему компоненту **:is-readonly="true"**, или просто **is-readonly**. Самый радикальный вариант, это определить высоту компонента, высоту экрана, и если высота компонента сильно больше высоты экрана, то в таком случае можно отключить возможность маркирования картинок, и вывести текст, что-то вроде "маркирование на мобильном устройтве не доступно". Но это совсем крайняя мера.

Желательно, чтобы блок (**div, main, article, section**) в котором будет находиться мой компонент не имел **position: relative**. При маркировании, когда вы выходите за пределы блока, процесс маркирования не останавливается, вы можете отпустить кнопку в любом месте, тогда будет создана маркированная область. Если вы отпустите левую кнопку мыши на блоке, который имеет больший **z-index**, чем блок в котором лежит мой компонент, то мой компонент про это ничего не узнает, и процесс маркирования не прекратится. Имейте это ввиду.