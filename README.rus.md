# Vue markup document

[English](./README.md) | Русский

Vue labeling image - это компонент для vue.js, позволяющий маркировать данные на картинках. Проще говоря, это UI для нейронок. Примером для создания данного компонента послужил данный [проект](https://github.com/HumanSignal/labelImg "LabelImg"), сейчас он уже не актуален. Eсли вам интересна данная тема, я рекомендую вам обратить внимание вот на этот [репозиторий](https://github.com/HumanSignal/label-studio "label-studio"). По большей части я разрабатывал компоненты для маркирования текста, поэтому основное предназначение моего компонента это OCR, но он подойдет и для других похожих задач. Как пример, я могу указать на yandex и google картинки. Там можно загрузить свою картирку, а после выделить какую-то определенную её область, мой компонент вполне с этой задачей справится.

Для корректной работы данного компонента нужен vue.js версии 3.5 и выше (я использую useTemplateRef и defineModel). При разработке данного компонента я использовал vue.js версии 3.5.17.

Чтобы не переписывать код в пустую, я бы вам посоветовал открыть [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры") и самим посмотреть, что может мой компонент. Я укажу ссылки на примеры с кодом, так наверное будет проще.

И так, откройте [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры"), выберите какую-нибудь картинку, и разметьте произвольные области (нажмите левую кнопку мыши, и не отпуская её выделите произвольную область. Если вы смотрите страницу примеров с мобильного телефона, то проведите пальцем по картинке). Маркированные области можно переносить по картинке и менять их размеры, для этого потяните их за края.

## Установка, минимальная настройка

Как и положено, наверное стоит сказать, что для установки данного компонента нужен Node.js и NPM, но вы наверное и сами это знаете. Установить данный компонент можно следующим способом:

```shell
npm install vue-labeling-image;
```

Если у вас нет проблем с интернетом, то компонент вы установите. Дальше нужно будет его подключить, это можно будет сделать следующим способом:

```vue
<template>
  <labeling-image
    :image-src="file"
    v-model="areas"
  />
</template>

<script setup>
  import LabelingImage from 'vue-labeling-image';
  import 'vue-labeling-image/styles.css';

  const file = ref(null);
  const areas = ref([]);
</script>
```

Если вы планируете использовать мой компонент более чем на одной странице, то имеет смысл подключить CSS глобально, в main.js, или App.vue, тут выбирайте как вам будет удобнее.

Как можно заметить, важными являются 2 строчки, **image-src="file"** и **v-model="areas"**.

**Image-src** - входной параметр, в который нужно передать картинку которую нужно маркировать. В подавляющем большинстве случаев, это будет двоичный файл, но возможно передать и путь к картинке, и саму картинку в формате base64. Вполне естественно, что без этого параметра ничего маркировать не получится. Саму картинку вы скорее всего отправите на сервер через **FormData**. Я бы порекомендовал вам посмотреть [код примера](https://github.com/neuro-tools-25/vue-labeling-image/blob/main/src/components/examples/MainExample.vue "Пример"). Если вы начинающий frontend-разработчик, то я рекомендую вам посмотреть код того, как работает [стилизованный input выбора файла](https://github.com/neuro-tools-25/vue-labeling-image/blob/main/src/UI/UIFile.vue "Пример").

**Areas** - это массив объектов. Он содержит параметры маркированных областей и обязательно должен содержать следующие поля:

```javascript
const areas = [
  {
    id: 1759337013345,
    x: 15,
    y: 15,
    width: 30,
    height: 30,
  }
];
```

Тут нужно оговориться, что единого API для нейронок не существует. Когда я первый раз писал UI для нейронки, мне нужно было указать координаты начальной и конечной точки (**X1, Y1, X2, Y2**). После, для одного НИИ нужно было создать UI, который бы принимал и отдавал начальую и конечную точку в следующем виде: **\[\[X1, Y1\], \[X2, Y2\]\]**. Это массив, в котором находятся координаты начальной и конечной точки, первый массив это начальная точка, второй массив это конечная точка. На аутсорсе я писал UI которое бы принимало и отдавало координаты в следующем виде:

```javascript
{
  name_area: [
    {
      x: "10",
      y: "10"
    },
    {
      x: "10",
      y: "40"
    },
    {
      x: "40",
      y: "40"
    },
    {
      x: "40",
      y: "10"
    }
  ]
}
```

Чтобы вы не ломали голову, это массив, в котором 4 объекта, это точки. Они идут от верхней левой, к нижней левой точке, затем к правой нижней точке, и последняя точка - правая верхняя. Как не трудно догадаться, получается прямоугольник, мне нужно было его построить. Возвращать маркированные области мне нужно было в этих форматах, в зависимости от API. Последнее из того, что я делал, нейронке была нужна начальная точка (координаты X, Y) и ширина с высотой маркированной области.

Если подводить не большой итог, можно выделить, что для всех нейронок, координаты точек должны быть представлены в относительных величинах (процентах). Смотрите, картинки могут быть разными, возможно загрузить картинку в 2000px и в 300px. Если область в которую нужно вставить картинку 600px, то на картинке в 2000px при точных величинах (px), нейронка не сможет понять, где искать текст, она же сожмется до 600px. Нужно будет ещё отправить размеры области в которую картинка вставляется. Это лишние расчеты. Гораздо проще отправить данные в относительных величинах, а нейронка эти данные разметит как нужно.

В моём случае **id** - это id маркированной области, по умолчанию, во время маркирования, это текущая дата в милисекундах, но если back вернет что-то другое, то ничего страшного. Главное, чтобы id-ки у маркированных областей были уникальными. **X** и **y** - это координаты начальной точки, **width** и **height** это ширина и высота маркированной области.

Как можно догадаться, за основу я взял последнее из того, что я делал. На мой взгляд такое API более понятно человеку. В будующем я планирую сделать так, чтобы мой компонент подстраивался под любое API, но пока что, мой компонент будет строить маркированные области так.

## Рекомендации по использованию

Eсли вы планируете использовать мой компонент на мобильном устройстве или планшете, то имейте в виду следующее. Когда картинка не выбрана, вы можете прокручивать вниз когда касаетесь моего компонента. Когда же картинка выбрана, то вниз прокрутить вы уже не сможете, скорее всего при касании моего компонента у вас будут появляться маркированные области. Для того, чтобы картинку можно было маркировать, мне приходится отключать обычное поведение для **touch**, иначе маркировать ничего не получится, при маркировании будет происходить прокрутка вниз/вверх. Самый простой вариант, это оставить по краям не большое расстояние, оно нужно для того, чтобы касаясь его можно было прокручивать вниз/вверх. Как вариант, можно добавить кнопку, которая бы включала/отключала возможность редактирования компонента. Для этого просто добавьте к моему компоненту **:is-readonly="true"**, или просто **is-readonly**. Самый радикальный вариант, это определить высоту компонента, высоту экрана, и если высота компонента сильно больше высоты экрана, то в таком случае можно отключить возможность маркирования картинок, и вывести текст, что-то вроде "маркирование на мобильном устройтве не доступно". Но это совсем крайняя мера.

Желательно, чтобы блок (**div, main, article, section**) в котором будет находиться мой компонент не имел **position: relative**. При маркировании, когда вы выходите за пределы блока, процесс маркирования не останавливается, вы можете отпустить кнопку в любом месте, тогда будет создана маркированная область. Если вы отпустите левую кнопку мыши на блоке, который имеет больший **z-index**, чем блок в котором лежит мой компонент, то мой компонент про это ничего не узнает, и процесс маркирования не прекратится. Имейте это ввиду.

## Методы, более полная настройка

Скорее всего, данный раздел вам не пригодится, но написать про него стоит. Ниже я приведу пример, он условный, и нужен для того, чтобы объяснить как добавлять методы к моему компоненту. Для того, чтобы посмотреть как работают методы, откройте [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры") и кликнете по заголовку "методы". Посмотреть код примера можно по [следующей ссылке](https://github.com/neuro-tools-25/vue-labeling-image/blob/main/src/components/examples/MethodsExample.vue "Пример").

```vue
<template>
  <labeling-image
    :image-src="file"
    v-model="areas"
    v-model:active-id="activeId"
    @is-load-image="changeIsLoadImage"
    @get-sizes="changeSizes"
  />
</template>

<script setup>
  import LabelingImage from 'vue-labeling-image';
  import 'vue-labeling-image/styles.css';

  const file = ref(null);
  const areas = ref([]);
  const activeId = ref(null);
  const isLoadImg = ref(false);
  const widthImg = ref(null);
  const heightImg = ref(null);
  const realWidthImg = ref(null);
  const realHeightImg = ref(null);

  const changeIsLoadImage = (isLoad) => isLoadImg.value = isLoad;

  const changeSizes = ({
    widthImage,
    heightImage,
    realWidthImage,
    realHeightImage,
  }) => {
    widthImg.value = widthImage;
    heightImg.value = heightImage;
    realWidthImg.value = realWidthImage;
    realHeightImg.value = realHeightImage;
  }
</script>
```

**@is-load-image** - данный метод нужен для того, чтобы узнать загрузилась картинка, или нет. Он возвращает булево значение **true**, если картинка загрузилась, и **false**, если возникла ошибка при загрузке картинки. Я бы посоветовал вам открыть [страницу настроек](https://neuro-tools-25.github.io/vue-labeling-image/settings?lang=rus "Страница настроек"), и вставить в поле **"imageSrc"** путь к какой-нибудь картинке. Если у вас нет никаких идей вставьте вот этот путь:

```shell
https://lapkins.ru/upload/resize_cache/uf/c8f/293_293_2/c8f2a2f9868aec552e5819f100a9652c.jpg 
```

У вас должен подгрузиться фокстерьер. Когда он подгрузится, кнопка "Выберите файл" станет зеленой, что говорит о том, что картинка подгрузилась. Попробуйте удалить какую-нибуль букву, кнопка снова станет синей. Это делается заменой переменной **isLoadImg** с true на false. Если вдруг по этому адресу картинки не будет, то попробуйте вставить свою картинку. Сайт не мой, а за картинкой я следить не могу.

Как не трудно догадаться, этот метод нужен для определения правильно ли подгрузилась картинка, или нет. Если **file** не равен **null**, а значение возвращаемое этим методом равно **false**, значит что-то пошло не так. Обычно если для поля выбора файла задать **accept="image/\*"**, то на компьютере будут видны только картинки, а вот на мобильном устройстве, пользователь сможет выбрать не только картинки, но и документы. PDF к примеру. В таком случае можно выводить сообщение, что "произошла ошибка во время загрузки картинки". Если же картинка подгрузилась нормально, то можно вывести какой-нибудь блок. В примерах я вывожу блок для маркированных областей.

**@get-sizes** - данный метод скорее всего вам не пригодится. Он возвращает размеры картинки для маркирования. Возвращаются её реальные размеры и размеры при масштабировании (когда она вставлена в блок). Соответственно **widthImage** и **heightImage** это размеры когда она вставлены в блок (масштабирована). **RealWidthImage** и **realHeightImage** - это реальные размеры картинки. Если ширина картинки 2000px, а она вставляется в блок в 600px, то ее реальная ширина (realWidthImage) будет равна 2000px, а масштабированная ширина (widthImage) будет равна ширине блока, соответственно 600px.

Как я выше писал, для большинства нейронок будут нужны относительные величины (проценты). Но не исключено, что по техническому заданию вам нужно будет передать масштабированные размеры картинки. Данный метод для этого.

У меня был такой случай, я отправлял на сервер картинку с маркированными областями, а на сервере программист не мог определить её реальные размеры. Так хорошо язык java он не знал. Меня попросили передавать реальные размеры картинки. В принципе это был единственный раз, и как я выше писал вероятность того, что вы будете этот метод использовать очень мала.

**v-model:active-id** - возвращает id активной области, доступен для редактирования. По умолчанию, когда я добавляю маркированные области (в моем примере я их добавляю в начало массива **areas**), я возвращаю id-ик добавленной области, и делаю её активной. Если вы откроете [страницу примеров](https://neuro-tools-25.github.io/vue-labeling-image/examples?lang=rus "Примеры"), и разметите какую-нибудь картинку, то у вас появятся блоки с маркированными областями. Если вы будете по ним кликать, то активная маркированная область будет меняться, это можно заметить по тому, что маркированные области будут менять цвет. Активная область у меня имеет красный цвет. Как пример, вам пришла с сервера какая-нибудь картинка с маркированными областями. Вы их вывели, и вам нужно узнать где какая область находится на картинке. Кликая по блокам можно будет это определить. Или другой пример, вам пришла картинка с маркированными областями, и кликая по ним, вам нужно будет подгружать данные в зависимости от выбранного id-ка.